<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>知识点 | 柯里君</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="向阳而生">
    
    <link rel="preload" href="/assets/css/0.styles.bb684b6e.css" as="style"><link rel="preload" href="/assets/js/app.a7ca910e.js" as="script"><link rel="preload" href="/assets/js/3.f4bec4dd.js" as="script"><link rel="preload" href="/assets/js/23.8f81c4fb.js" as="script"><link rel="prefetch" href="/assets/js/10.ebf7a222.js"><link rel="prefetch" href="/assets/js/11.9b36eb97.js"><link rel="prefetch" href="/assets/js/12.5166295c.js"><link rel="prefetch" href="/assets/js/13.52220468.js"><link rel="prefetch" href="/assets/js/14.5d789c73.js"><link rel="prefetch" href="/assets/js/15.6bdf57bf.js"><link rel="prefetch" href="/assets/js/16.e9ec0cca.js"><link rel="prefetch" href="/assets/js/17.e124f494.js"><link rel="prefetch" href="/assets/js/18.def0669f.js"><link rel="prefetch" href="/assets/js/19.1512e15f.js"><link rel="prefetch" href="/assets/js/20.8686d5f4.js"><link rel="prefetch" href="/assets/js/21.5e3e6a00.js"><link rel="prefetch" href="/assets/js/22.98ea15d1.js"><link rel="prefetch" href="/assets/js/24.71a19794.js"><link rel="prefetch" href="/assets/js/25.6479f418.js"><link rel="prefetch" href="/assets/js/26.73e74951.js"><link rel="prefetch" href="/assets/js/27.fa0ed151.js"><link rel="prefetch" href="/assets/js/28.c2e85e20.js"><link rel="prefetch" href="/assets/js/29.126b3608.js"><link rel="prefetch" href="/assets/js/4.84d1cee1.js"><link rel="prefetch" href="/assets/js/5.8feca752.js"><link rel="prefetch" href="/assets/js/6.7f0ce380.js"><link rel="prefetch" href="/assets/js/7.03a52a57.js"><link rel="prefetch" href="/assets/js/8.aab68a82.js"><link rel="prefetch" href="/assets/js/9.23ee45a7.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.4b42ec77.js">
    <link rel="stylesheet" href="/assets/css/0.styles.bb684b6e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">柯里君</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="iOS" class="dropdown-title"><span class="title">iOS</span> <span class="arrow down"></span></button> <button type="button" aria-label="iOS" class="mobile-dropdown-title"><span class="title">iOS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/iOS/interview/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  知识点
</a></li></ul></div></div><div class="nav-item"><a href="/cook/" class="nav-link">
  下厨房
</a></div><div class="nav-item"><a href="/note/homebrew.html" class="nav-link">
  笔记
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="iOS" class="dropdown-title"><span class="title">iOS</span> <span class="arrow down"></span></button> <button type="button" aria-label="iOS" class="mobile-dropdown-title"><span class="title">iOS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/iOS/interview/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  知识点
</a></li></ul></div></div><div class="nav-item"><a href="/cook/" class="nav-link">
  下厨房
</a></div><div class="nav-item"><a href="/note/homebrew.html" class="nav-link">
  笔记
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>知识点</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/iOS/interview/#目录" class="sidebar-link">目录</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/iOS/interview/#多线程" class="sidebar-link">多线程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/iOS/interview/#进程和线程" class="sidebar-link">进程和线程</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#多进程和多线程" class="sidebar-link">多进程和多线程</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#多线程优缺点" class="sidebar-link">多线程优缺点</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#任务和队列" class="sidebar-link">任务和队列</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#gcd" class="sidebar-link">GCD</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#nsthread" class="sidebar-link">NSThread</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#nsopertion" class="sidebar-link">NSOpertion</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#对比-ios-中的多线程技术" class="sidebar-link">对比 iOS 中的多线程技术</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#" class="sidebar-link"></a></li></ul></li><li><a href="/iOS/interview/#网络" class="sidebar-link">网络</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/iOS/interview/#http-和-https" class="sidebar-link">HTTP 和  HTTPS</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#tcp-和-udp" class="sidebar-link">TCP 和 UDP</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#三次握手和四次挥手" class="sidebar-link">三次握手和四次挥手</a></li></ul></li><li><a href="/iOS/interview/#ios-中的加密" class="sidebar-link">iOS 中的加密</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/iOS/interview/#base64编码" class="sidebar-link">Base64编码</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#对称加密" class="sidebar-link">对称加密</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#非对称加密" class="sidebar-link">非对称加密</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#哈希算法加密" class="sidebar-link">哈希算法加密</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#nsarray-与-nsset-的区别" class="sidebar-link">NSArray 与 NSSet 的区别</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#nshashtable-与-nsmaptable-的区别" class="sidebar-link">NSHashTable 与 NSMapTable 的区别</a></li></ul></li><li><a href="/iOS/interview/#内存管理" class="sidebar-link">内存管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/iOS/interview/#内存管理方式有哪些" class="sidebar-link">内存管理方式有哪些？</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#arc" class="sidebar-link">ARC</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#mrc-文件在-arc-工程混合编译时-需要在文件的-compiler-flags-上添加什么参数" class="sidebar-link">MRC 文件在 ARC 工程混合编译时，需要在文件的 Compiler Flags 上添加什么参数？</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#苹果是如何实现-autoreleasepool-的" class="sidebar-link">苹果是如何实现 autoreleasepool 的？</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#自动释放池-autorelease-pool" class="sidebar-link">自动释放池 Autorelease Pool</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#释放内存的方式" class="sidebar-link">释放内存的方式？</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#调用对象的-release-方法会销毁对象吗" class="sidebar-link">调用对象的 release 方法会销毁对象吗？</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#以下代码存在什么问题-怎么解决" class="sidebar-link">以下代码存在什么问题？怎么解决？</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#自动释放池的生命周期" class="sidebar-link">自动释放池的生命周期？</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#什么时候需要在程序中创建内存池" class="sidebar-link">什么时候需要在程序中创建内存池?</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#如果我们不创建内存池-是否有内存池提供给我们" class="sidebar-link">如果我们不创建内存池，是否有内存池提供给我们?</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#对象添加到通知中心中-当通知中心发通知时-这个对象却已经被释放了-可能会出现什么问题" class="sidebar-link">对象添加到通知中心中，当通知中心发通知时，这个对象却已经被释放了，可能会出现什么问题？</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#arc-默认的关键字" class="sidebar-link">ARC 默认的关键字</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#什么情况下使用-weak-关键字" class="sidebar-link">什么情况下使用 weak 关键字？</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#可能出现循环引用的地方有哪些" class="sidebar-link">可能出现循环引用的地方有哪些？</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#weak-跟-assign-的区别" class="sidebar-link">weak 跟 assign 的区别？</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#性能优化" class="sidebar-link">性能优化</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#objc-使用什么机制管理对象内存" class="sidebar-link">objc 使用什么机制管理对象内存？</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#ios-有没有垃圾回收" class="sidebar-link">iOS 有没有垃圾回收？</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#autorelease-和-gc-garbage-collection-有什么关系" class="sidebar-link">autorelease 和 GC（Garbage Collection) 有什么关系?</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#ios-是如何管理内存的" class="sidebar-link">iOS 是如何管理内存的？</a></li><li class="sidebar-sub-header"><a href="/iOS/interview/#七层模型" class="sidebar-link">七层模型</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="知识点"><a href="#知识点" class="header-anchor">#</a> 知识点</h1> <h2 id="目录"><a href="#目录" class="header-anchor">#</a> 目录</h2> <p></p><div class="table-of-contents"><ul><li><a href="#目录">目录</a></li><li><a href="#多线程">多线程</a><ul><li><a href="#进程和线程">进程和线程</a></li><li><a href="#多进程和多线程">多进程和多线程</a></li><li><a href="#多线程优缺点">多线程优缺点</a></li><li><a href="#任务和队列">任务和队列</a></li><li><a href="#gcd">GCD</a></li><li><a href="#nsthread">NSThread</a></li><li><a href="#nsopertion">NSOpertion</a></li><li><a href="#对比-ios-中的多线程技术">对比 iOS 中的多线程技术</a></li><li><a href="#"></a></li></ul></li><li><a href="#网络">网络</a><ul><li><a href="#http-和-https">HTTP 和  HTTPS</a></li><li><a href="#tcp-和-udp">TCP 和 UDP</a></li><li><a href="#三次握手和四次挥手">三次握手和四次挥手</a></li></ul></li><li><a href="#ios-中的加密">iOS 中的加密</a><ul><li><a href="#base64编码">Base64编码</a></li><li><a href="#对称加密">对称加密</a></li><li><a href="#非对称加密">非对称加密</a></li><li><a href="#哈希算法加密">哈希算法加密</a></li><li><a href="#nsarray-与-nsset-的区别">NSArray 与 NSSet 的区别</a></li><li><a href="#nshashtable-与-nsmaptable-的区别">NSHashTable 与 NSMapTable 的区别</a></li></ul></li><li><a href="#内存管理">内存管理</a><ul><li><a href="#内存管理方式有哪些">内存管理方式有哪些？</a></li><li><a href="#arc">ARC</a></li><li><a href="#mrc-文件在-arc-工程混合编译时-需要在文件的-compiler-flags-上添加什么参数">MRC 文件在 ARC 工程混合编译时，需要在文件的 Compiler Flags 上添加什么参数？</a></li><li><a href="#苹果是如何实现-autoreleasepool-的">苹果是如何实现 autoreleasepool 的？</a></li><li><a href="#自动释放池-autorelease-pool">自动释放池 Autorelease Pool</a></li><li><a href="#释放内存的方式">释放内存的方式？</a></li><li><a href="#调用对象的-release-方法会销毁对象吗">调用对象的 release 方法会销毁对象吗？</a></li><li><a href="#以下代码存在什么问题-怎么解决">以下代码存在什么问题？怎么解决？</a></li><li><a href="#自动释放池的生命周期">自动释放池的生命周期？</a></li><li><a href="#什么时候需要在程序中创建内存池">什么时候需要在程序中创建内存池?</a></li><li><a href="#如果我们不创建内存池-是否有内存池提供给我们">如果我们不创建内存池，是否有内存池提供给我们?</a></li><li><a href="#对象添加到通知中心中-当通知中心发通知时-这个对象却已经被释放了-可能会出现什么问题">对象添加到通知中心中，当通知中心发通知时，这个对象却已经被释放了，可能会出现什么问题？</a></li><li><a href="#arc-默认的关键字">ARC 默认的关键字</a></li><li><a href="#什么情况下使用-weak-关键字">什么情况下使用 weak 关键字？</a></li><li><a href="#可能出现循环引用的地方有哪些">可能出现循环引用的地方有哪些？</a></li><li><a href="#weak-跟-assign-的区别">weak 跟 assign 的区别？</a></li><li><a href="#性能优化">性能优化</a></li><li><a href="#objc-使用什么机制管理对象内存">objc 使用什么机制管理对象内存？</a></li><li><a href="#ios-有没有垃圾回收">iOS 有没有垃圾回收？</a></li><li><a href="#autorelease-和-gc-garbage-collection-有什么关系">autorelease 和 GC（Garbage Collection) 有什么关系?</a></li><li><a href="#ios-是如何管理内存的">iOS 是如何管理内存的？</a></li><li><a href="#七层模型">七层模型</a></li></ul></li></ul></div><p></p> <h2 id="多线程"><a href="#多线程" class="header-anchor">#</a> 多线程</h2> <h3 id="进程和线程"><a href="#进程和线程" class="header-anchor">#</a> 进程和线程</h3> <h4 id="进程"><a href="#进程" class="header-anchor">#</a> 进程</h4> <ul><li>进程是操作系统进行资源分配（CPU、内存、硬盘io等）的最小单位。</li> <li>进程是指在系统中正在运行的一个应用程序。每个进程之间都是独立的，每个进程均运行在其专用且受保护的内存空间内，拥有独立运行所需的全部资源。</li> <li>进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程，它们就是处于运行状态下的操作系统本身；所有由用户启动的进程都是用户进程。</li></ul> <h4 id="线程"><a href="#线程" class="header-anchor">#</a> 线程</h4> <ul><li>程序执行流的最小单元，线程是进程中的一个实体。</li> <li>一个进程要想执行任务，必须至少有一条线程。应用程序启动的时候，系统会默认开启一条线程，也就是主线程。</li></ul> <h4 id="进程和线程的关系"><a href="#进程和线程的关系" class="header-anchor">#</a> 进程和线程的关系</h4> <ul><li>线程是进程的执行单元，进程的所有任务都在线程中执行。</li> <li>进程是 CPU 分配资源和调度的最小单位。</li> <li>一个程序可以对应多个进程（多进程），一个进程中可有多个线程，但至少要有一条线程。</li> <li>同一个进程内的线程共享进程资源。</li></ul> <h3 id="多进程和多线程"><a href="#多进程和多线程" class="header-anchor">#</a> 多进程和多线程</h3> <h4 id="多进程"><a href="#多进程" class="header-anchor">#</a> 多进程</h4> <ul><li>进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。显然，程序是死的（静态的），进程是活的（动态的）。</li> <li>进程又被细化为线程，也就是一个进程下有多个能独立运行的更小的单位。在同一个时间里，同一个计算机系统中如果允许两个或者两个以上的进程处于运行状态，这便是多进程。</li></ul> <h4 id="多线程-2"><a href="#多线程-2" class="header-anchor">#</a> 多线程</h4> <ul><li>同一时间，CPU 只能处理一条线程，只有一条线程在执行。多线程并发执行，其实是 CPU 快速地在多条线程之间调度（切换）。如果 CPU 调度线程的时间足够快，就造成了多线程并发执行的假象。</li> <li>如果线程非常多，CPU 会在多个线程之间调度，消耗大量的 CPU 资源，每条线程被调度执行的频次会降低（线程的执行效率降低）。</li></ul> <h3 id="多线程优缺点"><a href="#多线程优缺点" class="header-anchor">#</a> 多线程优缺点</h3> <h4 id="多线程的优点"><a href="#多线程的优点" class="header-anchor">#</a> 多线程的优点</h4> <ul><li>能适当提高程序的执行效率。</li> <li>能适当提高资源的利用率（CPU、内存利用率）。</li></ul> <h4 id="多线程的缺点"><a href="#多线程的缺点" class="header-anchor">#</a> 多线程的缺点</h4> <ul><li>开启线程需要占用一定的内存空间（默认情况下，主线程占用 1M ，子线程占用 512KB），如果开启大量的线程，会占用大量的内存空间，降低程序性能。</li> <li>线程越多，CPU 在调度线程上的开销就越大。</li> <li>程序设计的更加复杂：比如线程之间的通信、多线程的数据共享。</li></ul> <h3 id="任务和队列"><a href="#任务和队列" class="header-anchor">#</a> 任务和队列</h3> <h4 id="任务"><a href="#任务" class="header-anchor">#</a> 任务</h4> <p>就是执行操作的意思，也就是在线程中执行的那段代码。在 GCD 中是放在 block 中的。执行任务有两种 方式：同步执行（sync）和异步执行（async）。</p> <ul><li><strong>同步(Sync)：</strong> 同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的 任务完成之后再继续执行，即会阻塞线程。只能在当前线程中执行任务（是当前线程，不一定是主线程）， 不具备开启新线程的能力。</li> <li><strong>异步(Async)：</strong> 线程会立即返回，无需等待就会继续执行下面的任务，不阻塞当前线程。可以在新的线程中 执行任务，具备开启新线程的能力（并不一定开启新线程）。如果不是添加到主队列上，异步会在子线程中 执行任务。</li></ul> <h4 id="队列"><a href="#队列" class="header-anchor">#</a> 队列</h4> <p>这里的队列指执行任务的等待队列，即用来存放任务的队列。队列是一种特殊 的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从 队列的头部开始读取。每读取一个任务，则从队列中释放一个任务 在 GCD 中有两种队列：串行队列和并发队列。两者都符合 FIFO（先进先出）的原则。两者的主要区别是： 执行顺序不同，以及开启线程数不同。</p> <ul><li><strong>串行队列（Serial Dispatch Queue）：</strong> 同一时间内，队列中只能执行一个任务，只有当前的任务执行完成之后，才能执行下一个任务。（只开启一个线程，一个任务执行完毕后，再执行下一个任务）。主队列是主线程上的一个串行队列,是 系统自动为我们创建的。</li> <li><strong>并发队列（Concurrent Dispatch Queue）：</strong> 同时允许多个任务并发执行。（可以开启多个线程，并且同时执行任务）。并发队列的并发功能只有 在异步（dispatch_async）函数下才有效。</li></ul> <h3 id="gcd"><a href="#gcd" class="header-anchor">#</a> GCD</h3> <h3 id="nsthread"><a href="#nsthread" class="header-anchor">#</a> NSThread</h3> <h3 id="nsopertion"><a href="#nsopertion" class="header-anchor">#</a> NSOpertion</h3> <h3 id="对比-ios-中的多线程技术"><a href="#对比-ios-中的多线程技术" class="header-anchor">#</a> 对比 iOS 中的多线程技术</h3> <h3 id=""><a href="#" class="header-anchor">#</a></h3> <h2 id="网络"><a href="#网络" class="header-anchor">#</a> 网络</h2> <h3 id="http-和-https"><a href="#http-和-https" class="header-anchor">#</a> HTTP 和  HTTPS</h3> <h4 id="http"><a href="#http" class="header-anchor">#</a> HTTP</h4> <p>超文本传输协议，是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息。<br>
HTTP 是基于 TCP 的应用层协议 (OSI 网络七层协议从上到下分别是 应用层、表示层、会话层 、传输层、网络层 、数据链路层、物理层）
<strong>发展历史：</strong></p> <table><thead><tr><th>版本</th> <th>产生时间</th> <th>内容</th> <th>发展现状</th></tr></thead> <tbody><tr><td>HTTP/0.9</td> <td>1991</td> <td>不涉及数据包传输，规定客户端和服务器之间通信格式，只能GET请求</td> <td>没有作为正式的标准</td></tr> <tr><td>HTTP/1.0</td> <td>1996</td> <td>传输内容格式不限制，增加 PUT、PATCH、HEAD、 OPTIONS、DELETE 命令</td> <td>正式作为标准</td></tr> <tr><td>HTTP/1.1</td> <td>1997</td> <td>持久连接(长连接)、节约带宽、HOST 域、管道机制、分块传输编码</td> <td>2015年前使用最广泛</td></tr> <tr><td>HTTP/2</td> <td>2015</td> <td>多路复用、服务器推送、头信息压缩、二进制协议等</td> <td>逐渐覆盖市场</td></tr></tbody></table> <h4 id="https"><a href="#https" class="header-anchor">#</a> HTTPS</h4> <p>超文本传输安全协议，是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p> <h4 id="http-与-https-的区别"><a href="#http-与-https-的区别" class="header-anchor">#</a> HTTP 与 HTTPS 的区别</h4> <ul><li>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（ SSL/TLS 协议+ HTTP ） 数据传输过程是加密的，安全性较好。</li> <li>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</li> <li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS 除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</li> <li>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li> <li>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</li></ul> <h4 id="http-请求常用的几种方式"><a href="#http-请求常用的几种方式" class="header-anchor">#</a> HTTP 请求常用的几种方式</h4> <ul><li>GET：获取指定资源。请求体中不会包含请求数据，请求数据放在协议头中。另外 GET 支持快取、缓存、可保留书签等。幂等。（幂等性是数学中的一个概念，表达的是N次变换与1次变换的结果相同）。</li> <li>POST：向指定资源提交数据进行处理请求。比如提交表单、上传文件等，可能导致建立新的资源或者对原有资源的修改。提交的资源放在请求体中。不支持快取，非幂等。</li> <li>HEAD：获取指定资源头部信息。</li> <li>PUT：替换指定资源（不支持浏览器操作）。</li> <li>DELETE：删除指定资源。</li></ul> <h4 id="post-与-get-的区别"><a href="#post-与-get-的区别" class="header-anchor">#</a> POST 与 GET 的区别</h4> <ul><li>GET 是从服务器上获取数据，POST 是向服务器传送数据。</li> <li>GET 请求会被浏览器主动cache，POST 不会，除非手动设置。</li> <li>GET 请求只能进行 URL 编码，POST 支持多种编码方式。</li> <li>GET 请求参数会被完整保留在浏览器历史记录里，POST 中的参数不会被保留。</li> <li>GET 只接受 ASCII 字符的参数的数据类型，POST 没有限制。</li> <li>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。</li></ul> <h3 id="tcp-和-udp"><a href="#tcp-和-udp" class="header-anchor">#</a> TCP 和 UDP</h3> <h4 id="tcp"><a href="#tcp" class="header-anchor">#</a> TCP</h4> <p>TCP（Transmission Control Protocol，传输控制协议）：传输控制协议，提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须现在双方之间建立一个 TCP 连接，一个 TCP 连接必须经过“三次握手”才能建立起来，之后才能传输数据。TCP 提供超时重发、丢弃重复数据、检验数据、流量控制等功能，保证数据能从一端传到另一端。</p> <h4 id="udp"><a href="#udp" class="header-anchor">#</a> UDP</h4> <p>UDP（User Data Protocol，用户数据报协议）：用户数据报协议，是一个简单的面向数据报的运输层协议。UDP 适用于一次只传送少量数据、对可靠性要求不好的应用环境。UDP 提不同可靠性，它只是把应用程式传给 IP 层的数据报发送出去，但是并不能保证它们能到达目的地。由于 UDP 在传输数据报前不用在客户端和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。</p> <h4 id="tcp-和-udp-的区别"><a href="#tcp-和-udp-的区别" class="header-anchor">#</a> TCP 和 UDP 的区别</h4> <ul><li>TCP 是面向连接，UDP 是非面向连接（ UPD 传输数据前不需要先建立连接）。</li> <li>TCP 传输可靠，UDP 传输不可靠。</li> <li>TCP 保证数据顺序， UDP 不保证数据顺序。</li></ul> <h3 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="header-anchor">#</a> 三次握手和四次挥手</h3> <h4 id="三次握手"><a href="#三次握手" class="header-anchor">#</a> 三次握手</h4> <p><strong>第一次握手：</strong> 建立连接时，客户端发送 SYN 包（ syn = j ）到服务器，并进入 SYN_SEND 状态，等待服务器确认。<br> <strong>第二次握手：</strong> 服务器收到 SYN 包，必须确认客户的 SYN（ ack = j + 1 ），同时自己也发送一个 SYN 包 （ syn = k ），即 SYN + ACK 包，此时服务器进入 SYN_RECV 状态。<br> <strong>第三次握手：</strong> 客户端收到服务器的 SYN + ACK 包，向服务器发送确认包 ACK（ ack = k + 1），此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。</p> <h4 id="四次挥手"><a href="#四次挥手" class="header-anchor">#</a> 四次挥手</h4> <p><strong>第一次挥手：</strong> 客户应用进程发出一个关闭连接的指令。会引起客户端 TCP 向服务端发送一个特殊的 TCP 报文段。该 报文段即是将首部的一个标志位 FIN 比特置为 1。同时，客户端进入 FIN_WAIT_1 状态，等待服务端的带有确认的 TCP 报文段。<br> <strong>第二次挥手：</strong> 收到该报文段后会向客户端发送一个确认报文段。服务端 TCP 进入 CLOSE_WAIT 状态，对应客户端的 TIME_WAIT，表示被动关闭。客户端收到该报文段后，进入 FIN_WAIT_2 状态，等待服务端的 FIN 比特置为 1 的报文段。<br> <strong>第三次挥手：</strong> 服务端发送自己的终止报文段，同样是把报文段首部的标志位 FIN 比特置为 1。服务端 TCP 进入 LAST_ACK 状态，等待服务端最后的确认报文段。<br> <strong>第四次挥手：</strong> 客户端收到服务端的终止报文段后，向服务端发送一个确认报文段。同时，客户端进入 TIME_WAIT 状态。假如 ACK 丢失，TIME_WAIT 状态使 TCP 客户重传最后的确认报文，TIME_WAIT 通常会等待 2MSL （Maximum Segment Lifetime 最长报文段寿命）。经过等待后，连接就正式关闭，重新进入 CLOSED 状态，客户端所有资源将被释放。服务端收到该报文段后，同样也会关闭，重新进入 CLOSED 状态，释放所有服务端 TCP 资源。</p> <h4 id="为什么建立连接只用三次握手-而断开连接却要四次挥手"><a href="#为什么建立连接只用三次握手-而断开连接却要四次挥手" class="header-anchor">#</a> 为什么建立连接只用三次握手，而断开连接却要四次挥手？</h4> <p>服务端的 FIN 和 ACK 需要分开发，并不是像三次握手中那样，SYN 可以和 ACK 同步发，所以就需要四次挥手。</p> <h4 id="在四次挥手中-客户端为什么在-time-wait-后必须等待-2msl-时间呢"><a href="#在四次挥手中-客户端为什么在-time-wait-后必须等待-2msl-时间呢" class="header-anchor">#</a> 在四次挥手中，客户端为什么在 TIME_WAIT 后必须等待 2MSL 时间呢？</h4> <p>为了保证客户端发送的最后一个 ACK 报文段能够到达服务端。</p> <h2 id="ios-中的加密"><a href="#ios-中的加密" class="header-anchor">#</a> iOS 中的加密</h2> <h3 id="base64编码"><a href="#base64编码" class="header-anchor">#</a> Base64编码</h3> <p>Base64编码要求把3个8位字节（3<em>8=24）转化为4个6位的字节（4</em>6=24），之后在6位的前面补两个0，形成8位一个字节的形式。 如果剩下的字符不足3个字节，则用0填充，输出字符使用'='，因此编码后输出的文本末尾可能会出现1或2个'='。<br>
Base64编码为转码，不是加密方式，只为数据存储容易和方便网络传输的一种数据处理方式。</p> <div class="language-objc extra-class"><pre class="language-objc"><code><span class="token comment">/// base64编码</span>
<span class="token comment">/// @param string 字符串</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>base64Encoding<span class="token punctuation">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>string <span class="token punctuation">{</span>
    <span class="token comment">// UTF8编码二进制数据</span>
    NSData <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token punctuation">[</span>string dataUsingEncoding<span class="token punctuation">:</span>NSUTF8StringEncoding<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 编码后的字符串</span>
    NSString <span class="token operator">*</span>base64String <span class="token operator">=</span> <span class="token punctuation">[</span>data base64EncodedStringWithOptions<span class="token punctuation">:</span>NSDataBase64Encoding64CharacterLineLength<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;%@ base64编码后：%@&quot;</span><span class="token punctuation">,</span>string<span class="token punctuation">,</span>base64String<span class="token punctuation">)</span>
    <span class="token keyword">return</span> base64String<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/// base64解码</span>
<span class="token comment">/// @param string 字符串</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>base64Decoding<span class="token punctuation">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>string <span class="token punctuation">{</span>
    <span class="token comment">// 解码</span>
    NSData <span class="token operator">*</span>base64Data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>NSData alloc<span class="token punctuation">]</span> initWithBase64EncodedString<span class="token punctuation">:</span>string options<span class="token punctuation">:</span>NSDataBase64DecodingIgnoreUnknownCharacters<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 二进制转换</span>
    NSString <span class="token operator">*</span>decodingSting <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>NSString alloc<span class="token punctuation">]</span> initWithData<span class="token punctuation">:</span>base64Data encoding<span class="token punctuation">:</span>NSUTF8StringEncoding<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;%@ base64解码后：%@&quot;</span><span class="token punctuation">,</span>string<span class="token punctuation">,</span>decodingSting<span class="token punctuation">)</span>
    <span class="token keyword">return</span> decodingSting<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/// base64编码</span>
<span class="token comment">/// @param string 字符串</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>fileBase64Encoding<span class="token punctuation">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>string <span class="token punctuation">{</span>
    <span class="token comment">// http://img.kelijun.com/naixiangmalatang_003.jpg</span>
    NSURL <span class="token operator">*</span>url <span class="token operator">=</span> <span class="token punctuation">[</span>NSURL URLWithString<span class="token punctuation">:</span>string<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 需要加密的二进制数据</span>
    NSData <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>NSData alloc<span class="token punctuation">]</span> initWithContentsOfURL<span class="token punctuation">:</span>url<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">//    // 编码后的二进制数据</span>
<span class="token comment">//    NSData *base64Data = [data base64EncodedDataWithOptions:NSDataBase64Encoding64CharacterLineLength];</span>
    <span class="token comment">// 编码后的字符串</span>
    NSString <span class="token operator">*</span>base64String <span class="token operator">=</span> <span class="token punctuation">[</span>data base64EncodedStringWithOptions<span class="token punctuation">:</span>NSDataBase64Encoding64CharacterLineLength<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span><span class="token keyword">self</span> fileBase64Decoding<span class="token punctuation">:</span>base64String<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;%@ base64编码后：%@&quot;</span><span class="token punctuation">,</span>string<span class="token punctuation">,</span>base64String<span class="token punctuation">)</span>
    <span class="token keyword">return</span> base64String<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/// base64解码</span>
<span class="token comment">/// @param string 字符串</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>NSData <span class="token operator">*</span><span class="token punctuation">)</span>fileBase64Decoding<span class="token punctuation">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>string <span class="token punctuation">{</span>
    <span class="token comment">// 解码后的二进制数据</span>
    NSData <span class="token operator">*</span>decodingData <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>NSData alloc<span class="token punctuation">]</span> initWithBase64EncodedString<span class="token punctuation">:</span>string options<span class="token punctuation">:</span>NSDataBase64DecodingIgnoreUnknownCharacters<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">//    // 解码后的二进制数据</span>
<span class="token comment">//    NSData *decodingData = [[NSData alloc] initWithBase64EncodedData:data options:NSDataBase64DecodingIgnoreUnknownCharacters];</span>
    <span class="token keyword">return</span> decodingData<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="对称加密"><a href="#对称加密" class="header-anchor">#</a> 对称加密</h3> <p>用同一套密钥来进行加密解密。对称加密通常有 DES、AES、IDEA、3DES 加密算法。</p> <h4 id="des-data-encryption-standard"><a href="#des-data-encryption-standard" class="header-anchor">#</a> DES（Data Encryption Standard）</h4> <p>DES 密码体制的安全性不依赖于算法的保密，其安全性以加密密钥的保密为基础。DES 算法的入口参数有三个：Key、Data、Mode。其中 Key 为8个字节共64位，是 DES 算法的工作密钥；Data 也为8个字节64位，是要被加密或被解密的数据；Mode 为 DES 的工作方式，有两种：加密或解密。</p> <h4 id="aes-the-advanced-encryption-standard"><a href="#aes-the-advanced-encryption-standard" class="header-anchor">#</a> AES（The Advanced Encryption Standard）</h4> <p>AES 算法是基于置换和代替的。置换是数据的重新排列，而代替是用一个单元数据替换另一个。</p> <h4 id="_3des-triple-data-encryption-algorithm"><a href="#_3des-triple-data-encryption-algorithm" class="header-anchor">#</a> 3DES（Triple Data Encryption Algorithm）</h4> <p>它相当于是对每个数据块应用三次 DES 加密算法。</p> <h4 id="idea-international-data-encryption-algorithm"><a href="#idea-international-data-encryption-algorithm" class="header-anchor">#</a> IDEA（International Data Encryption Algorithm）</h4> <p>在 DES 算法的基础上发展出来的，类似于 3DES 。IDEA 是作为迭代的分组密码实现的，使用128位的密钥和8个循环。</p> <h3 id="非对称加密"><a href="#非对称加密" class="header-anchor">#</a> 非对称加密</h3> <p>用公钥和私钥来加解密的算法。<br>
公钥（Public Key）与私钥（Private Key）是通过一种算法得到的一个密钥对（即一个公钥和一个私钥）， 公钥是密钥对中公开的部分，私钥则是非公开的部分,私钥通常是保存在本地。</p> <ul><li>用公钥进行加密，就要用私钥进行解密；反之，用私钥加密，就要用公钥进行解密（数字签名）。</li> <li>由于私钥是保存在本地的，所以非对称加密相对与对称加密是安全的。 但非对称加密比对称加密耗时(100 倍以上),所以通常要结合对称加密来使用。
常见的非对称加密算法有：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）。   而为了确保客户端能够确认公钥就是想要访问的网站的公钥，引入了数字证书的概念，由于证书存在一级 一级的签发过程，所以就出现了证书链，在证书链中的顶端的就是根 CA。</li></ul> <h4 id="rsa-the-advanced-encryption-standard"><a href="#rsa-the-advanced-encryption-standard" class="header-anchor">#</a> RSA（The Advanced Encryption Standard）</h4> <h3 id="哈希算法加密"><a href="#哈希算法加密" class="header-anchor">#</a> 哈希算法加密</h3> <h4 id="md5"><a href="#md5" class="header-anchor">#</a> MD5</h4> <p>输入不定长度信息，输出固定长度128-bits的算法。经过程序流程，生成四个32位数据，最后联合起来成为一个128-bits散列。基本方式为，求余、取余、调整长度、与链接变量进行循环运算。得出结果。</p> <div class="language-objc extra-class"><pre class="language-objc"><code><span class="token comment">/// MD5加密</span>
<span class="token comment">/// @param string 需要加密的字符</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>getMD5<span class="token punctuation">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>string <span class="token punctuation">{</span>
    <span class="token comment">// 要进行UTF8的转码</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> input <span class="token operator">=</span> <span class="token punctuation">[</span>string UTF8String<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> digest<span class="token punctuation">[</span>CC_MD5_DIGEST_LENGTH<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">CC_MD5</span><span class="token punctuation">(</span> input<span class="token punctuation">,</span> <span class="token punctuation">(</span>CC_LONG<span class="token punctuation">)</span><span class="token function">strlen</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">,</span> digest <span class="token punctuation">)</span><span class="token punctuation">;</span>
    NSMutableString <span class="token operator">*</span>output <span class="token operator">=</span> <span class="token punctuation">[</span>NSMutableString stringWithCapacity<span class="token punctuation">:</span>CC_MD5_DIGEST_LENGTH <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> CC_MD5_DIGEST_LENGTH<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">[</span>output appendFormat<span class="token punctuation">:</span><span class="token string">@&quot;%02x&quot;</span><span class="token punctuation">,</span> digest<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span>  output<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="sha"><a href="#sha" class="header-anchor">#</a> SHA</h4> <p>安全哈希算法（Secure Hash Algorithm）主要适用于数字签名标准（Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要。当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。当让除了SHA1还有SHA256以及SHA512等。</p> <h4 id="hmac"><a href="#hmac" class="header-anchor">#</a> HMAC</h4> <p>给定一个密钥，对明文加密，做两次“散列”，得到的结果还是32为字符串。在实际开发中，密钥是服务器生成，客户端发送请求会拿到KEY，一个账号对应一个KEY。</p> <h3 id="nsarray-与-nsset-的区别"><a href="#nsarray-与-nsset-的区别" class="header-anchor">#</a> NSArray 与 NSSet 的区别</h3> <ul><li>NSArray 内存中储存地址连续，NSSet 不连续。</li> <li>NSArray 查找需要遍历，NSSet 效率高，内部使用 hash 查找。</li> <li>NSArray 通过下标访问，NSSet 通过 anyObject 访问元素。</li></ul> <h3 id="nshashtable-与-nsmaptable-的区别"><a href="#nshashtable-与-nsmaptable-的区别" class="header-anchor">#</a> NSHashTable 与 NSMapTable 的区别</h3> <ul><li>NSHashTable 是 NSSet 的通用版本，对元素弱引用，可变类型，可以在访问成员时 copy。</li> <li>NSMapTable 是 NSDictionary 的通用版本，对元素弱引用，可变类型；可以在访问成员时 copy.</li></ul> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>NSHashTable与NSSet的区别：NSHashTable可以通过option设置元素弱引用/copyin，只有可变类型。但是添加对象的时候NSHashTable耗费时间是NSSet的两倍。
NSMapTable与NSDictionary的区别：同上</p></div> <h4 id="oc-的优点"><a href="#oc-的优点" class="header-anchor">#</a> OC 的优点</h4> <ol><li>Cateogies</li> <li>Posing</li> <li>动态识别</li> <li>指标计算</li> <li>不是一个过度复杂的 C 衍生语言</li> <li>OC 可以与 C++ 混编</li></ol> <h4 id="oc-的缺点"><a href="#oc-的缺点" class="header-anchor">#</a> OC 的缺点</h4> <ol><li>不支持多重继承，只有多级继承。</li> <li>不支持运算符重载。</li> <li>使用动态运行时类型，所有的方法都是函数调用，所以很多编译时优化方法都用不到，如内联函数等，性能低劣。</li> <li>程序执行效率：汇编 &gt; C &gt; OC。</li></ol> <h4 id="oc-的三大特性"><a href="#oc-的三大特性" class="header-anchor">#</a> OC 的三大特性</h4> <p>封装 分类 继承</p> <h4 id="swift-的优势-oc-的劣势"><a href="#swift-的优势-oc-的劣势" class="header-anchor">#</a> Swift 的优势 OC 的劣势</h4> <ol><li>Swift 语法和文件结构简易化，文件分离后结构更清晰。</li> <li>Swift更加安全，它是类型安全的语言。</li> <li>Swift速度更快，运算性能更高。</li> <li>不像C语言和OC语言一样都必须有一个主函数main()作为程序的入口, swift程序从第一句开始向下顺序执行, 一直到最后。</li></ol> <h4 id="swift-的劣势-oc的优势"><a href="#swift-的劣势-oc的优势" class="header-anchor">#</a> Swift 的劣势 OC的优势</h4> <ol><li>不稳定</li> <li>Runtime对Swift支持不太友好屏蔽了好多下层Api</li></ol> <h4 id="kvo-与-kvc-的区别"><a href="#kvo-与-kvc-的区别" class="header-anchor">#</a> KVO 与 KVC 的区别</h4> <p>KVO键值观察机制。一对多，观察者模式，提供观察某一属性变化的方法。KVO基于KVC。
KVC：键值编码，是一个通过属性名访问对象的属性。</p> <h4 id="简述-notification、kvc、kvo、delegate"><a href="#简述-notification、kvc、kvo、delegate" class="header-anchor">#</a> 简述 Notification、KVC、KVO、delegate</h4> <p>KVO：键值观察机制。一对多，观察者模式，提供观察某一属性变化的方法。
KVC：键值编码。一个对象在调用 setValue 时：</p> <ol><li>检查是否存在对应key的set方法，存在就调用 set 方法。</li> <li>set 方法不存在，就查找 _key 的成员变量是否存在，存在就直接赋值。</li> <li>如果 _key 没有找到，就查找相同名称的 key ，存在就赋值。</li> <li>如果都没有找到，就调用 valueForUndefinedKey 方法 和 setValue:forUndefinedKey 方法。
delegate：发送和接收者的关系是直接、一对一的关系。
Notification：观察者模式，发送者和接受者的关系是间接、多对多的关系。
delegate 的效率比 Notification 高
Notification 更直接，需要关注返回值，常带有 should 关键字。Notification 不关心结果，常带有 did 关键字。</li></ol> <h4 id="怎么用-copy-关键字"><a href="#怎么用-copy-关键字" class="header-anchor">#</a> 怎么用 copy 关键字？</h4> <p>NSString、NSArray、NSDictionary等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，为确保对象中的属性值不会无意间变动，应该在设置新属性值时拷贝一份，保护其封装性。<br>
block 也经常使用copy关键字，block 使用 copy 是从 MRC 遗留下来的“传统”。在 MRC 中，方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区。在ARC中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但是建议写上copy，因为这样显示告知调用者“编译器会自动对 block 进行了 copy 操作”</p> <h4 id="如何让自己写的对象有拷贝功能"><a href="#如何让自己写的对象有拷贝功能" class="header-anchor">#</a> 如何让自己写的对象有拷贝功能？</h4> <p>遵从 NSCopying 协议或者 NSMutableCopying 协议，实现该协议 - (id)copyWitZone:(NSZone *)zone;</p> <h4 id="property-的本质是什么"><a href="#property-的本质是什么" class="header-anchor">#</a> @property 的本质是什么？</h4> <p>@property = ivar + getter + setter;</p> <h4 id="ivar、getter、setter-是如何生成并添加到这个类中的"><a href="#ivar、getter、setter-是如何生成并添加到这个类中的" class="header-anchor">#</a> ivar、getter、setter 是如何生成并添加到这个类中的？</h4> <p>在编译期自动生成 getter、setter ，还自动向类中添加适当的实例变量，也可以用 @synthesize 语法来指定实例变量的名字。</p> <h4 id="protocol-和-category-中如何使用-property"><a href="#protocol-和-category-中如何使用-property" class="header-anchor">#</a> @protocol 和 category 中如何使用 @property？</h4> <p>在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性；<br>
category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：</p> <div class="language- extra-class"><pre class="language-text"><code>objc_setAssociatedObject 
objc_getAssociatedObject
</code></pre></div><h4 id="id-和-nil-代表什么"><a href="#id-和-nil-代表什么" class="header-anchor">#</a> id 和 nil 代表什么？</h4> <p>id 类型的指针可以指向任何 OC 对象。<br>
nil 代表空值（空指针的值，0）。</p> <p>property</p> <h4 id="atomic"><a href="#atomic" class="header-anchor">#</a> atomic</h4> <ul><li>保证数据只能被一个线程占用，也就是说线程对属性进行写操作时，会使用自旋锁锁住该属性，不允许其它的线程对其进行操作。</li> <li>自旋锁会对getter/setter方法会进行加锁操作，仅仅保证getter/setter方法的线程安全，方法之外的线程安全还是要靠自己处理。</li> <li>原子属性采用的是多读单写机制的多线程策略，多读单写缩小了锁的范围，比互斥锁的性能好。规定只能在主线程中更新UI，就是因为如果在多线程中更新UI，就需要给UI加锁，防止抢占资源写入错误，但这样降低性能，所以iOS的设计让所有的UI对象都是非线程安全的（不加锁），并规定只能在主线程中更新UI，避免多线程抢占资源问题。</li></ul> <h4 id="nonatomic"><a href="#nonatomic" class="header-anchor">#</a> nonatomic</h4> <h4 id="strong"><a href="#strong" class="header-anchor">#</a> strong</h4> <h4 id="weak"><a href="#weak" class="header-anchor">#</a> weak</h4> <h4 id="assgin"><a href="#assgin" class="header-anchor">#</a> assgin</h4> <h4 id="copy"><a href="#copy" class="header-anchor">#</a> copy</h4> <h4 id="retain"><a href="#retain" class="header-anchor">#</a> retain</h4> <h4 id="unsafe-unretained"><a href="#unsafe-unretained" class="header-anchor">#</a> unsafe_unretained</h4> <h4 id="readonly"><a href="#readonly" class="header-anchor">#</a> readonly</h4> <h4 id="readwrite"><a href="#readwrite" class="header-anchor">#</a> readwrite</h4> <h4 id="简述-nil、nil、null、nsnull"><a href="#简述-nil、nil、null、nsnull" class="header-anchor">#</a> 简述 nil、Nil、NULL、NSNull</h4> <p>nil、Nil、NULL 都表示（void *）0；NSNull 继承于 NSObject，很特殊的类，表示空，什么也不储存，但它却是对象，只是一个占位对象。使用场景：比如服务端接口让传空，[NSNull null]</p> <h4 id="nil、nil、null、nsnull的区别"><a href="#nil、nil、null、nsnull的区别" class="header-anchor">#</a> nil、Nil、NULL、NSNull的区别？</h4> <p>nil 指向一个对象的空指针。<br>
Nil 指向一个类的空指针。<br>
NULL 在 C 语言中表示空指针。<br>
NSNull 表示空值的对象。</p> <h2 id="内存管理"><a href="#内存管理" class="header-anchor">#</a> 内存管理</h2> <h3 id="内存管理方式有哪些"><a href="#内存管理方式有哪些" class="header-anchor">#</a> 内存管理方式有哪些？</h3> <ul><li>MRC（manual retain-release）手动内存管理</li> <li>ARC（automatic reference counting）自动引用计数</li></ul> <h3 id="arc"><a href="#arc" class="header-anchor">#</a> ARC</h3> <p>自动引用计数，全称 Automatic Reference Counting。ARC 是 Objective-C 编译器的特性，而不是运行时特性或者垃圾回收机制，ARC 所做的只不过是在代码编译时为你自动在合适的位置插入 release 或 autorelease，只要没有强指针指向对象，对象就会被释放。<br>
在对象被创建时 retain count +1，在对象被 release 时 retain count -1.当 retain count 为0 时，销毁对象。程序中加入 autoreleasepool 的对象会由系统自动加上 autorelease 方法，如果该对象引用计数为0，则销毁。</p> <h4 id="系统判断对象是否销毁的依据"><a href="#系统判断对象是否销毁的依据" class="header-anchor">#</a> 系统判断对象是否销毁的依据？</h4> <p>指向对象的强指针是否被销毁。</p> <h4 id="如何解决arc机制下类的相互引用"><a href="#如何解决arc机制下类的相互引用" class="header-anchor">#</a> 如何解决arc机制下类的相互引用？</h4> <p>.h文件中使用 @class 关键字声明一个类，两端不能都用强指针，一端用 strong 一端用 weak</p> <h3 id="mrc-文件在-arc-工程混合编译时-需要在文件的-compiler-flags-上添加什么参数"><a href="#mrc-文件在-arc-工程混合编译时-需要在文件的-compiler-flags-上添加什么参数" class="header-anchor">#</a> MRC 文件在 ARC 工程混合编译时，需要在文件的 Compiler Flags 上添加什么参数？</h3> <p>-fno-objc-arc</p> <h3 id="苹果是如何实现-autoreleasepool-的"><a href="#苹果是如何实现-autoreleasepool-的" class="header-anchor">#</a> 苹果是如何实现 autoreleasepool 的？</h3> <p>autoreleasepool 以一个队列数组的形式实现，主要通过下列三个函数完成：</p> <ul><li>objc_autoreleasepoolPush</li> <li>objc_autoreleasepoolPop</li> <li>objc_autorelease</li></ul> <h3 id="自动释放池-autorelease-pool"><a href="#自动释放池-autorelease-pool" class="header-anchor">#</a> 自动释放池 Autorelease Pool</h3> <h3 id="释放内存的方式"><a href="#释放内存的方式" class="header-anchor">#</a> 释放内存的方式？</h3> <p>一种是[ objc release] 直接释放 还有一种是 [objc autorelease].当对象调用autorelease时，会将对象加入自动释放池中。自动释放池会在将来的某一时刻将存在池中的对象释放掉。清空自动释放时，系统会向其中的对象发送release消息。</p> <h3 id="调用对象的-release-方法会销毁对象吗"><a href="#调用对象的-release-方法会销毁对象吗" class="header-anchor">#</a> 调用对象的 release 方法会销毁对象吗？</h3> <p>不会，调用对象的 release 方法只是将对象的引用计数器-1，当引用计数器为0时，才会销毁对象。</p> <h3 id="以下代码存在什么问题-怎么解决"><a href="#以下代码存在什么问题-怎么解决" class="header-anchor">#</a> 以下代码存在什么问题？怎么解决？</h3> <div class="language-objc extra-class"><pre class="language-objc"><code>NSMutableArray <span class="token operator">*</span>tempMutArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>NSMutableArray alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4000000</span> <span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    NSString <span class="token operator">*</span>string <span class="token operator">=</span> <span class="token punctuation">[</span>NSString stringWithFormat<span class="token punctuation">:</span><span class="token string">@&quot;三&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span>tempMutArray addObject<span class="token punctuation">:</span>string<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>每执行一次循环，就会有一个 NSString 对象加到当前 Runloop 的自动释放池中，只有当 Runloop 退出时，自动释放池中标示了autorelease的这些数据所占用的内存空间才能被释放掉。<br>
如果 i 比较大，可以用 @autoreleasepool {}解决，放在 for 循环外，循环结束后，销毁创建的对象，解决占据栈区内存的问题</p> <div class="language-objc extra-class"><pre class="language-objc"><code>NSMutableArray <span class="token operator">*</span>tempMutArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>NSMutableArray alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token operator">@</span>autoreleasepool <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4000000</span> <span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        NSString <span class="token operator">*</span>string <span class="token operator">=</span> <span class="token punctuation">[</span>NSString stringWithFormat<span class="token punctuation">:</span><span class="token string">@&quot;三&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">[</span>tempMutArray addObject<span class="token punctuation">:</span>string<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果 i 玩命大，一次循环都会造成自动释放池被填满，自动释放池放在 for 循环内，每次循环都将上一次创建的对象 release</p> <div class="language-objc extra-class"><pre class="language-objc"><code>NSMutableArray <span class="token operator">*</span>tempMutArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>NSMutableArray alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">40000000</span> <span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">@</span>autoreleasepool <span class="token punctuation">{</span>
        NSString <span class="token operator">*</span>string <span class="token operator">=</span> <span class="token punctuation">[</span>NSString stringWithFormat<span class="token punctuation">:</span><span class="token string">@&quot;三&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">[</span>tempMutArray addObject<span class="token punctuation">:</span>string<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="自动释放池的生命周期"><a href="#自动释放池的生命周期" class="header-anchor">#</a> 自动释放池的生命周期？</h3> <ul><li>第一次创建：Runloop 启动的时候 。</li> <li>最后一次销毁：Runloop 退出的时候。</li> <li>其它时候的创建和销毁：Runloop 即将睡眠时销毁之前的释放池，重新创建一个新的。</li> <li>内存池满的时候也是释放。</li></ul> <h3 id="什么时候需要在程序中创建内存池"><a href="#什么时候需要在程序中创建内存池" class="header-anchor">#</a> 什么时候需要在程序中创建内存池?</h3> <p>用户自己创建的数据线程，则需要创建该线程的内存池。</p> <h3 id="如果我们不创建内存池-是否有内存池提供给我们"><a href="#如果我们不创建内存池-是否有内存池提供给我们" class="header-anchor">#</a> 如果我们不创建内存池，是否有内存池提供给我们?</h3> <p>界面线程维护着自己的内存池，用户自己创建的数据线程，则需要创建该线程的内存池。</p> <h3 id="对象添加到通知中心中-当通知中心发通知时-这个对象却已经被释放了-可能会出现什么问题"><a href="#对象添加到通知中心中-当通知中心发通知时-这个对象却已经被释放了-可能会出现什么问题" class="header-anchor">#</a> 对象添加到通知中心中，当通知中心发通知时，这个对象却已经被释放了，可能会出现什么问题？</h3> <p>若在对象销毁前不把对象从通知中心移除，当发送通知时，程序会崩溃。在对象添加到通知中心后，一定要在释放前移除。</p> <h3 id="arc-默认的关键字"><a href="#arc-默认的关键字" class="header-anchor">#</a> ARC 默认的关键字</h3> <p>普通 OC 对象：atomic strong readwrite。<br>
基本数据类型： atomic assign readwrite。</p> <h3 id="什么情况下使用-weak-关键字"><a href="#什么情况下使用-weak-关键字" class="header-anchor">#</a> 什么情况下使用 weak 关键字？</h3> <ul><li>ARC 中可能出现循环引用，比如 delegate 。</li> <li>自定义 IBOutlet 控件属性一般也适用 weak。</li></ul> <h3 id="可能出现循环引用的地方有哪些"><a href="#可能出现循环引用的地方有哪些" class="header-anchor">#</a> 可能出现循环引用的地方有哪些？</h3> <ul><li>delegate：ARC 中使用 weak，MRC 中使用 assign。</li> <li>block：某个类将 block 作为自己的的属性变量，该类在 block 中又使用了该类本身。通俗来讲就是该类持有 block，block 持有该类。可用 __weak 修饰该类解决循环引用。</li> <li>NSTimer：NSTimer 作为某个类的属性变量，而 NSTimer 初始化时要指定 self 为 target ，容易造成循环引用。若 NSTimer 一直处于 validate 状态下，则其引用计数一直大于0，因此在不使用定时器以后，应先调用 invalidate 方法。</li></ul> <h3 id="weak-跟-assign-的区别"><a href="#weak-跟-assign-的区别" class="header-anchor">#</a> weak 跟 assign 的区别？</h3> <p>weak 表明一种非持有关系，必须用于 OC 对象；<br>
assign 用于基本数据类型，也可以用于 OC 对象。</p> <h3 id="性能优化"><a href="#性能优化" class="header-anchor">#</a> 性能优化</h3> <h3 id="objc-使用什么机制管理对象内存"><a href="#objc-使用什么机制管理对象内存" class="header-anchor">#</a> objc 使用什么机制管理对象内存？</h3> <p>通过引用计数器（retainCount）的机制来决定对象是否需要释放。 每次 runloop 完成一个循环的时候，都会检查对象的 retainCount，如果 retainCount 为0，说明该对象没有地方需要继续使用了，可以释放掉了。</p> <h3 id="ios-有没有垃圾回收"><a href="#ios-有没有垃圾回收" class="header-anchor">#</a> iOS 有没有垃圾回收？</h3> <p>iOS 中没有垃圾回收。</p> <h3 id="autorelease-和-gc-garbage-collection-有什么关系"><a href="#autorelease-和-gc-garbage-collection-有什么关系" class="header-anchor">#</a> autorelease 和 GC（Garbage Collection) 有什么关系?</h3> <p>autorelease 只是延迟释放，GC 是发觉内存资源紧张的时候，就会自动地去清理无用对象（没有被引用到的对象）所占用的内存空间。他们两者没有什么关系。</p> <h3 id="ios-是如何管理内存的"><a href="#ios-是如何管理内存的" class="header-anchor">#</a> iOS 是如何管理内存的？</h3> <h3 id="七层模型"><a href="#七层模型" class="header-anchor">#</a> 七层模型</h3> <p>七层模型，亦称OSI（Open System Interconnection）。参考模型是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系，一般称为OSI参考模型或七层模型。</p> <h4 id="应用层"><a href="#应用层" class="header-anchor">#</a> 应用层</h4> <p>网络服务与最终用户的一个接口。
协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP</p> <h4 id="表示层"><a href="#表示层" class="header-anchor">#</a> 表示层</h4> <p>数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）
格式有，JPEG、ASCll、EBCDIC、加密格式等</p> <h4 id="会话层"><a href="#会话层" class="header-anchor">#</a> 会话层</h4> <p>建立、管理、终止会话。（在五层模型里面已经合并到了应用层）
对应主机进程，指本地主机与远程主机正在进行的会话</p> <h4 id="传输层"><a href="#传输层" class="header-anchor">#</a> 传输层</h4> <p>定义传输数据的协议端口号，以及流控和差错校验。
协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层</p> <h4 id="网络层"><a href="#网络层" class="header-anchor">#</a> 网络层</h4> <p>进行逻辑地址寻址，实现不同网络之间的路径选择。
协议有：ICMP IGMP IP（IPV4 IPV6）</p> <h4 id="数据链路层"><a href="#数据链路层" class="header-anchor">#</a> 数据链路层</h4> <p>建立逻辑连接、进行硬件地址寻址、差错校验 [3]  等功能。（由底层网络定义协议）
将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。</p> <h4 id="物理层"><a href="#物理层" class="header-anchor">#</a> 物理层</h4> <p>建立、维护、断开物理连接。（由底层网络定义协议）</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a7ca910e.js" defer></script><script src="/assets/js/3.f4bec4dd.js" defer></script><script src="/assets/js/23.8f81c4fb.js" defer></script>
  </body>
</html>
