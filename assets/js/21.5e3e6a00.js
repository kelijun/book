(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{384:function(a,t,e){"use strict";e.r(t);var s=e(42),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"ios-内存泄漏检测"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ios-内存泄漏检测"}},[a._v("#")]),a._v(" iOS 内存泄漏检测")]),a._v(" "),e("h2",{attrs:{id:"analyze-静态分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#analyze-静态分析"}},[a._v("#")]),a._v(" Analyze 静态分析")]),a._v(" "),e("h3",{attrs:{id:"简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[a._v("#")]),a._v(" 简介")]),a._v(" "),e("p",[a._v("Product -> Analyze（快捷键command+shift+B）可以找出代码潜在错误，如内存泄露、未使用函数和变量、循环引用等。\n"),e("img",{attrs:{src:"http://img.kelijun.com/MemoryLeak_Analyze_001.png",alt:"image"}})]),a._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[a._v("注意")]),a._v(" "),e("p",[a._v("所谓静态内存分析, 是指在程序没运行的时候, 通过工具对代码直接进行分析\n根据代码的上下文的语法结构, 让编译器分析内存情况, 检查是否有内存泄露")])]),a._v(" "),e("h3",{attrs:{id:"analyze-主要分析以下几种问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#analyze-主要分析以下几种问题"}},[a._v("#")]),a._v(" Analyze 主要分析以下几种问题：")]),a._v(" "),e("ul",[e("li",[a._v("逻辑错误：访问空指针或未初始化的变量等；")]),a._v(" "),e("li",[a._v("内存管理错误：如内存泄漏等；")]),a._v(" "),e("li",[a._v("声明错误：从未使用过的变量；")]),a._v(" "),e("li",[a._v("Api 调用错误：未包含使用的库和框架。")])]),a._v(" "),e("h2",{attrs:{id:"instruments-leaks"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#instruments-leaks"}},[a._v("#")]),a._v(" Instruments - Leaks")]),a._v(" "),e("h3",{attrs:{id:"三种打开方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三种打开方式"}},[a._v("#")]),a._v(" 三种打开方式")]),a._v(" "),e("h4",{attrs:{id:"第一种-xcode-opendevelper-tool-instruments-leaks"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一种-xcode-opendevelper-tool-instruments-leaks"}},[a._v("#")]),a._v(" 第一种：Xcode -> OpenDevelper Tool -> Instruments -> Leaks")]),a._v(" "),e("p",[e("img",{attrs:{src:"http://img.kelijun.com/MemoryLeak_Leaks_001.png",alt:"image"}}),a._v(" "),e("img",{attrs:{src:"http://img.kelijun.com/MemoryLeak_Leaks_002.png",alt:"image"}})]),a._v(" "),e("h4",{attrs:{id:"第二种-product-profile"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二种-product-profile"}},[a._v("#")]),a._v(" 第二种：Product -> Profile")]),a._v(" "),e("p",[e("img",{attrs:{src:"http://img.kelijun.com/MemoryLeak_Leaks_003.png",alt:"image"}})]),a._v(" "),e("h4",{attrs:{id:"第三种"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第三种"}},[a._v("#")]),a._v(" 第三种：")]),a._v(" "),e("p",[e("img",{attrs:{src:"http://img.kelijun.com/MemoryLeak_Leaks_004.png",alt:"image"}}),a._v(" "),e("img",{attrs:{src:"http://img.kelijun.com/MemoryLeak_Leaks_005.png",alt:"image"}})]),a._v(" "),e("h3",{attrs:{id:"配置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#配置"}},[a._v("#")]),a._v(" 配置")]),a._v(" "),e("p",[e("img",{attrs:{src:"http://img.kelijun.com/MemoryLeak_Leaks_006.png",alt:"image"}})]),a._v(" "),e("h3",{attrs:{id:"动态分析内存泄露"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#动态分析内存泄露"}},[a._v("#")]),a._v(" 动态分析内存泄露")]),a._v(" "),e("p",[a._v("首先运行 Leaks ，Leaks 是动态监测，需要操作 APP 观察 Leaks 的泄漏，出现红色叉号就监测到了内存泄露，可以先点击暂停运行。\n第一步，点击红色叉号标志；第二步，在第二行的菜单栏选择 Leaks -> Call Tree ；第三步：在底部的菜单栏选择 Call Tree；第四步：选择 Invert Call Tree 和 Hide System Libraries；如下图所示：")]),a._v(" "),e("ul",[e("li",[a._v("Separate by Thread：按线程分开做分析，这样更容易揪出那些吃资源的问题线程。特别是对于主线程，它要处理和渲染所有的接口数据，一旦受到阻塞，程序必然卡顿或停止响应。")]),a._v(" "),e("li",[a._v("Invert Call Tree：反向输出调用树。把调用层级最深的方法显示在最上面，更容易找到最耗时的操作。")]),a._v(" "),e("li",[a._v("Hide System Libraries：隐藏系统库文件。过滤掉各种系统调用，只显示自己的代码调用。")]),a._v(" "),e("li",[a._v("Flattern Recursion：拼合递归。将同一递归函数产生的多条堆栈（因为递归函数会调用自己）合并为一条。\n"),e("img",{attrs:{src:"http://img.kelijun.com/MemoryLeak_Leaks_007.png",alt:"image"}})])])])}),[],!1,null,null,null);t.default=r.exports}}]);